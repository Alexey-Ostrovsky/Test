#include "imports/stdlib.fc";

;; data sctructure:

;;  jetton minter address
;;  jetton wallet code

;;  owner address
;;  comission
;;  commision address


(slice, cell, slice, int, slice) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_msg_addr(),      ;;immutable data
        ds~load_ref(),

        ds~load_msg_addr(),      ;;mutable data
        ds~load_uint(8),
        ds~load_msg_addr()       ;;comission address
    );
}

() save_data (slice owner_address, int commission, slice commision_address) impure inline {
    slice ds = get_data().begin_parse();
    set_data(
        begin_cell()
            .store_slice(ds~load_msg_addr())        ;;immutable data
            .store_ref(ds~load_ref())

            .store_slice(owner_address)             ;;mutable data
            .store_uint(commission, 8)
            .store_slice(commision_address)
        .end_cell()
    );
}

(slice, int, slice) get_current_state() method_id {
    slice ds = get_data().begin_parse();
    ds~load_msg_addr();      ;;immutable data
    ds~load_ref();

    return (
        ds~load_msg_addr(),     ;;mutable data
        ds~load_uint(8),
        ds~load_msg_addr()      ;;comission address
    );
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if(flags & 1) {
        return ();
    }

    if(in_msg_body.slice_empty?()) {
        return ();
    }

    slice adress = cs~load_msg_addr();


    {-
    int notSoSecret = in_msg_body~load_uint(255);
    
    int key = load_data();

    if(notSoSecret == key) {
        var msg = begin_cell()
            .store_uint(0, 1)       ;; tag marking type of serialization, in this context - int_msg_info (internal message info)
            .store_uint(1, 1)       ;; Hypercube Routing disabled (something related to sharding?? - set 1 and fuck off)
            .store_uint(1, 1)       ;; allow bounces (some sort of replies????)
            .store_uint(0, 1)       ;; no itself bouncing
            .store_uint(0, 2)       ;; "none" addr of source, in fact all types of addreses have 2-bit tag similer to upper, but for $00 there is no need for other part of data https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb
            .store_slice(adress)    ;; destination address
            .store_coins(0)         ;; serialization, https://docs.ton.org/learn/tvm-instructions/instructions#:~:text=FA02-,STGRAMS%20STVARUINT16,-b%20x%20%2D%20b
            .store_uint(0, 1)       ;; disabling? dictionary for extra currencies, as i found out https://ton.org/tvm.pdf 40 page of doc - first bit marks that hash map is empty/not valid
            .store_uint(0, 4)       ;; ihr_fee - autofill, VARUINT16(similar to coins format)
            .store_uint(0, 4)       ;; fwd_fee - autofill, VARUINT16(similar to coins format)
            .store_uint(0, 64)      ;; created_lt - autofill, fixed size             .store_uint(cut_lt(), 64)
            .store_uint(0, 32)      ;; created_at - autofill, fixed size             .store_uint(now(), 32)
            .store_uint(0, 1)       ;; init flag, for deploy functioning
            .store_uint(1, 1)       ;; emplace message flag
            .store_ref(begin_cell()
                .store_int(2, 3)
                .end_cell()
            )
        .end_cell();

        send_raw_message(msg, 128 + 32);  ;; destroying contract
    }
    -}
    return();    
}
